<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trials Test Performance Comparison Dashboard</title>
    <link rel="stylesheet" href="/static/css/dashboard.css">
    <style>
        /* Layout styles */
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .dashboard-layout { display: flex; gap: 20px; }
        .control-panel {
            flex: 0 0 350px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            height: fit-content;
        }
        .plot-panel {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }

        /* Form styles */
        .form-group { margin-bottom: 15px; }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-control:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        /* Button styles */
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-top: 10px;
        }
        .btn:hover { background: #45a049; }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Header styles */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .header h1 { margin: 0 0 10px 0; }
        .header p { margin: 0; color: rgba(255,255,255,0.8); }

        /* Loading and error states */
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            color: #d32f2f;
            padding: 10px;
            background: #ffebee;
            border-radius: 4px;
            margin-top: 10px;
        }

        /* Plot container */
        #plotContainer {
            min-height: 500px;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        /* Multi-select styles */
        .multi-select {
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 120px;
            overflow-y: auto;
            padding: 5px;
        }
        .multi-select label {
            display: block;
            padding: 5px;
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        .multi-select label:hover {
            background: #f5f5f5;
        }
        .multi-select input[type="checkbox"] {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Trials Test Performance Comparison Dashboard</h1>
            <p>Dynamic field site, system and phase analysis with interactive plotting</p>
        </header>

        <div class="dashboard-layout">
            <!-- Control Panel -->
            <div class="control-panel">
                <h3>Selection Parameters</h3>

                <div class="form-group">
                    <label for="sites">Field Sites:</label>
                    <div id="sites" class="multi-select">
                        <div class="loading">Loading sites...</div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="system">System:</label>
                    <select id="system" class="form-control">
                        <option value="">Select a site first</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="phase">Phase:</label>
                    <select id="phase" class="form-control">
                        <option value="">Select a system first</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="variable">Variable:</label>
                    <select id="variable" class="form-control">
                        <option value="">Loading variables...</option>
                    </select>
                </div>

                <button id="plotBtn" class="btn" disabled>Plot Data</button>

                <div id="errorMessage" class="error" style="display: none;"></div>
            </div>

            <!-- Plot Panel -->
            <div class="plot-panel">
                <h3>Performance Comparison Plot</h3>
                <div id="plotContainer">
                    <div class="loading">
                        Select parameters and click "Plot Data" to generate the scatterplot
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let availableSites = [];
        let selectedSites = [];
        let selectedSystem = '';
        let selectedPhase = '';
        let selectedVariable = '';

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            loadSites();
            loadVariables();
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('system').addEventListener('change', function() {
                selectedSystem = this.value;
                loadPhases();
                updatePlotButton();
            });

            document.getElementById('phase').addEventListener('change', function() {
                selectedPhase = this.value;
                updatePlotButton();
            });

            document.getElementById('variable').addEventListener('change', function() {
                selectedVariable = this.value;
                updatePlotButton();
            });

            document.getElementById('plotBtn').addEventListener('click', generatePlot);
        }

        function loadSites() {
            fetch('/api/sites-json')
                .then(response => response.json())
                .then(data => {
                    availableSites = data.sites;
                    renderSitesCheckboxes();
                })
                .catch(error => {
                    console.error('Error loading sites:', error);
                    showError('Failed to load sites');
                });
        }

        function renderSitesCheckboxes() {
            const container = document.getElementById('sites');
            container.innerHTML = '';

            availableSites.forEach(site => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = site;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        if (!selectedSites.includes(site)) {
                            selectedSites.push(site);
                        }
                    } else {
                        selectedSites = selectedSites.filter(s => s !== site);
                    }
                    onSitesChanged();
                });

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(site));
                container.appendChild(label);
            });
        }

        function onSitesChanged() {
            // Reset dependent dropdowns
            document.getElementById('system').innerHTML = '<option value="">Select a system</option>';
            document.getElementById('phase').innerHTML = '<option value="">Select a phase</option>';
            selectedSystem = '';
            selectedPhase = '';

            if (selectedSites.length > 0) {
                // Load systems for the first selected site (could be enhanced to find common systems)
                loadSystems(selectedSites[0]);
            }

            updatePlotButton();
        }

        function loadSystems(site) {
            if (!site) return;

            fetch(`/api/systems-json?site=${encodeURIComponent(site)}`)
                .then(response => response.json())
                .then(data => {
                    const systemSelect = document.getElementById('system');
                    systemSelect.innerHTML = '<option value="">Select a system</option>';

                    data.systems.forEach(system => {
                        const option = document.createElement('option');
                        option.value = system;
                        option.textContent = system;
                        systemSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading systems:', error);
                    showError('Failed to load systems');
                });
        }

        function loadPhases() {
            if (!selectedSites.length || !selectedSystem) return;

            // Use first selected site for phases
            fetch(`/api/phases-json?site=${encodeURIComponent(selectedSites[0])}&system=${encodeURIComponent(selectedSystem)}`)
                .then(response => response.json())
                .then(data => {
                    const phaseSelect = document.getElementById('phase');
                    phaseSelect.innerHTML = '<option value="">Select a phase</option>';

                    data.phases.forEach(phase => {
                        const option = document.createElement('option');
                        option.value = phase;
                        option.textContent = phase;
                        phaseSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading phases:', error);
                    showError('Failed to load phases');
                });
        }

        function loadVariables() {
            fetch('/api/variables-json')
                .then(response => response.json())
                .then(data => {
                    const variableSelect = document.getElementById('variable');
                    variableSelect.innerHTML = '<option value="">Select a variable</option>';

                    data.variables.forEach(variable => {
                        const option = document.createElement('option');
                        option.value = variable;
                        option.textContent = variable;
                        variableSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading variables:', error);
                    showError('Failed to load variables');
                });
        }

        function updatePlotButton() {
            const plotBtn = document.getElementById('plotBtn');
            // Allow plotting with just a variable selected
            const canPlot = selectedVariable;
            plotBtn.disabled = !canPlot;
        }

        function generatePlot() {
            if (!selectedVariable) {
                showError('Please select a variable before plotting');
                return;
            }

            // Show loading
            document.getElementById('plotContainer').innerHTML = '<div class="loading">Generating plot...</div>';
            hideError();

            // Build API URL based on selection level
            let apiUrl = `/api/plot-data-json?variable=${encodeURIComponent(selectedVariable)}`;
            
            // Add parameters based on what's selected
            if (selectedSites.length > 0) {
                const sitesParam = selectedSites.join(',');
                apiUrl += `&sites=${encodeURIComponent(sitesParam)}`;
            }
            
            if (selectedSystem) {
                apiUrl += `&system=${encodeURIComponent(selectedSystem)}`;
            }
            
            if (selectedPhase) {
                apiUrl += `&phase=${encodeURIComponent(selectedPhase)}`;
            }

            // Fetch plot data
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(data.error);
                        document.getElementById('plotContainer').innerHTML = '<div class="loading">Error: ' + data.error + '</div>';
                        return;
                    }
                    
                    if (data.data && data.data.length > 0) {
                        createScatterPlot(data.data);
                    } else {
                        showError('No data found for the selected parameters');
                        document.getElementById('plotContainer').innerHTML = '<div class="loading">No data available for selected parameters</div>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching plot data:', error);
                    showError('Failed to fetch plot data');
                    document.getElementById('plotContainer').innerHTML = '<div class="loading">Error loading plot data</div>';
                });
        }

        function createScatterPlot(data) {
            // Determine the coloring scheme based on selection level
            let colorBy, groupBy, xAxisLabel, plotTitle, plotSubtitle;
            
            if (selectedSites.length === 0) {
                // No site selection - color by site
                colorBy = 'site';
                groupBy = 'site';
                xAxisLabel = 'Field Site';
                plotTitle = `${selectedVariable} by Field Site`;
                plotSubtitle = 'All sites, systems, and phases';
            } else if (!selectedSystem) {
                // Site(s) selected but no system - color by system
                colorBy = 'system';
                groupBy = 'system';
                xAxisLabel = 'System';
                plotTitle = `${selectedVariable} by System`;
                plotSubtitle = `Sites: ${selectedSites.join(', ')}`;
            } else if (!selectedPhase) {
                // Site(s) and system selected but no phase - color by phase
                colorBy = 'phase';
                groupBy = 'phase';
                xAxisLabel = 'Phase';
                plotTitle = `${selectedVariable} by Phase`;
                plotSubtitle = `Sites: ${selectedSites.join(', ')}, System: ${selectedSystem}`;
            } else {
                // All levels selected - use traditional site grouping
                colorBy = 'site';
                groupBy = 'site';
                xAxisLabel = 'Field Site';
                plotTitle = `${selectedVariable} by Field Site`;
                plotSubtitle = `System: ${selectedSystem}, Phase: ${selectedPhase}`;
            }

            // Group data by the determined grouping variable
            const groupedData = {};
            data.forEach(point => {
                const groupKey = point[groupBy];
                if (!groupedData[groupKey]) {
                    groupedData[groupKey] = [];
                }
                groupedData[groupKey].push(point);
            });

            const groupNames = Object.keys(groupedData);
            const plotContainer = document.getElementById('plotContainer');

            // Clear the container
            plotContainer.innerHTML = '';

            // Create SVG
            const svgWidth = 800;
            const svgHeight = 500;
            const margin = { top: 80, right: 50, bottom: 100, left: 80 };
            const plotWidth = svgWidth - margin.left - margin.right;
            const plotHeight = svgHeight - margin.top - margin.bottom;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.border = '1px solid #ddd';
            svg.style.borderRadius = '4px';

            // Get value range for y-axis
            const allValues = data.map(d => parseFloat(d.value)).filter(v => !isNaN(v));
            const minY = Math.min(...allValues);
            const maxY = Math.max(...allValues);
            const yPadding = (maxY - minY) * 0.1;
            const yMin = minY - yPadding;
            const yMax = maxY + yPadding;

            // Color palette - extended for more categories
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];

            // Helper functions for scaling
            function scaleX(groupIndex, jitter = 0.1) {
                const groupSpacing = plotWidth / (groupNames.length || 1);
                return margin.left + groupSpacing * (groupIndex + 0.5) + jitter;
            }

            function scaleY(value) {
                return margin.top + plotHeight - ((value - yMin) / (yMax - yMin)) * plotHeight;
            }

            // Draw axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', margin.top + plotHeight);
            xAxis.setAttribute('x2', margin.left + plotWidth);
            xAxis.setAttribute('y2', margin.top + plotHeight);
            xAxis.setAttribute('stroke', '#666');
            xAxis.setAttribute('stroke-width', '2');
            svg.appendChild(xAxis);

            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', margin.top + plotHeight);
            yAxis.setAttribute('stroke', '#666');
            yAxis.setAttribute('stroke-width', '2');
            svg.appendChild(yAxis);

            // Draw y-axis ticks and labels
            const numYTicks = 5;
            for (let i = 0; i <= numYTicks; i++) {
                const value = yMin + (yMax - yMin) * (i / numYTicks);
                const y = scaleY(value);

                // Tick line
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', margin.left - 5);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', margin.left);
                tick.setAttribute('y2', y);
                tick.setAttribute('stroke', '#666');
                svg.appendChild(tick);

                // Tick label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-family', 'Arial, sans-serif');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = value.toFixed(1);
                svg.appendChild(label);
            }

            // Draw x-axis labels (group names)
            groupNames.forEach((groupName, groupIndex) => {
                const x = scaleX(groupIndex);

                // Tick line
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', margin.top + plotHeight);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', margin.top + plotHeight + 5);
                tick.setAttribute('stroke', '#666');
                svg.appendChild(tick);

                // Group label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', margin.top + plotHeight + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-family', 'Arial, sans-serif');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = groupName;
                svg.appendChild(label);
            });

            // Draw data points
            groupNames.forEach((groupName, groupIndex) => {
                const groupData = groupedData[groupName];
                const color = colors[groupIndex % colors.length];

                groupData.forEach((point, pointIndex) => {
                    const value = parseFloat(point.value);
                    if (isNaN(value)) return;

                    // Add jitter to x position
                    const jitter = (Math.random() - 0.5) * 40; // Â±20px jitter
                    const x = scaleX(groupIndex, jitter);
                    const y = scaleY(value);

                    // Create circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '5');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('fill-opacity', '0.7');
                    circle.setAttribute('stroke', color);
                    circle.setAttribute('stroke-width', '1');
                    circle.style.cursor = 'pointer';

                    // Add tooltip on hover
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${colorBy.charAt(0).toUpperCase() + colorBy.slice(1)}: ${groupName}\nSite: ${point.site}\nSystem: ${point.system}\nPhase: ${point.phase}\nPlot: ${point.plot}\nValue: ${value.toFixed(2)}`;
                    circle.appendChild(title);

                    svg.appendChild(circle);
                });
            });

            // Add title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', svgWidth / 2);
            title.setAttribute('y', 25);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-family', 'Arial, sans-serif');
            title.setAttribute('font-size', '16');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('fill', '#333');
            title.textContent = plotTitle;
            svg.appendChild(title);

            // Add subtitle
            const subtitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            subtitle.setAttribute('x', svgWidth / 2);
            subtitle.setAttribute('y', 45);
            subtitle.setAttribute('text-anchor', 'middle');
            subtitle.setAttribute('font-family', 'Arial, sans-serif');
            subtitle.setAttribute('font-size', '12');
            subtitle.setAttribute('fill', '#666');
            subtitle.textContent = plotSubtitle;
            svg.appendChild(subtitle);

            // Add axis labels
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 20);
            yLabel.setAttribute('y', svgHeight / 2);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('font-family', 'Arial, sans-serif');
            yLabel.setAttribute('font-size', '14');
            yLabel.setAttribute('fill', '#333');
            yLabel.setAttribute('transform', `rotate(-90, 20, ${svgHeight / 2})`);
            yLabel.textContent = selectedVariable;
            svg.appendChild(yLabel);

            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', svgWidth / 2);
            xLabel.setAttribute('y', svgHeight - 10);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('font-family', 'Arial, sans-serif');
            xLabel.setAttribute('font-size', '14');
            xLabel.setAttribute('fill', '#333');
            xLabel.textContent = xAxisLabel;
            svg.appendChild(xLabel);

            // Add legend
            const legendStartY = margin.top + 10;
            const legendItemHeight = 20;
            groupNames.forEach((groupName, index) => {
                const color = colors[index % colors.length];
                const legendY = legendStartY + index * legendItemHeight;
                
                // Legend color box
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', svgWidth - margin.right - 100);
                rect.setAttribute('y', legendY - 8);
                rect.setAttribute('width', '12');
                rect.setAttribute('height', '12');
                rect.setAttribute('fill', color);
                rect.setAttribute('stroke', color);
                svg.appendChild(rect);
                
                // Legend text
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', svgWidth - margin.right - 80);
                text.setAttribute('y', legendY);
                text.setAttribute('font-family', 'Arial, sans-serif');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#333');
                text.textContent = groupName;
                svg.appendChild(text);
            });

            // Add to container
            plotContainer.appendChild(svg);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
    </script>
</body>
</html>