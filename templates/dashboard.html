<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trials Test Performance Comparison Dashboard</title>
    <link rel="stylesheet" href="/static/css/dashboard.css">
    <style>
        /* Layout styles */
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .dashboard-layout { display: flex; gap: 20px; }
        .control-panel {
            flex: 0 0 350px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            height: fit-content;
        }
        .plot-panel {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }

        /* Form styles */
        .form-group { margin-bottom: 15px; }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-control:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        /* Button styles */
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-top: 10px;
        }
        .btn:hover { background: #45a049; }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        /* Secondary button styles */
        .btn-secondary {
            background: #6c757d !important;
            margin-top: 5px !important;
        }
        .btn-secondary:hover {
            background: #5a6268 !important;
        }
        .btn-secondary:disabled {
            background: #ccc !important;
        }

        /* Header styles */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .header h1 { margin: 0 0 10px 0; }
        .header p { margin: 0; color: rgba(255,255,255,0.8); }

        /* Loading and error states */
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            color: #d32f2f;
            padding: 10px;
            background: #ffebee;
            border-radius: 4px;
            margin-top: 10px;
        }

        /* Plot container */
        #plotContainer {
            min-height: 500px;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        /* Multi-select styles */
        .multi-select {
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 120px;
            overflow-y: auto;
            padding: 5px;
        }
        .multi-select label {
            display: block;
            padding: 5px;
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        .multi-select label:hover {
            background: #f5f5f5;
        }
        .multi-select input[type="checkbox"] {
            margin-right: 8px;
        }

        /* Site info styling */
        .site-info {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            background-color: #f8f9fa;
            color: #666;
            font-style: italic;
        }

        /* Variable requirement styling */
        .variable-required.required {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2) !important;
        }

        .variable-warning {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
            font-weight: bold;
        }

        .btn.variable-required {
            background-color: #dc3545 !important;
            border-color: #dc3545 !important;
        }

        .btn.variable-required:hover {
            background-color: #c82333 !important;
            border-color: #bd2130 !important;
        }

        /* Plot type toggle styles */
        .plot-type-toggle {
            display: flex;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        .toggle-option {
            flex: 1;
            margin: 0 !important;
            padding: 8px 12px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            transition: background-color 0.2s;
        }
        .toggle-option:last-child {
            border-right: none;
        }
        .toggle-option:hover {
            background: #e9ecef;
        }
        .toggle-option input[type="radio"] {
            display: none;
        }
        .toggle-option input[type="radio"]:checked + span {
            background: #4CAF50;
            color: white;
            padding: 8px 12px;
            margin: -8px -12px;
            display: block;
        }

        /* Compare mode specific styles */
        .compare-mode #system.form-control,
        .compare-mode #phase.form-control {
            display: none !important;
        }
        .compare-mode #systemMultiSelect,
        .compare-mode #phaseMultiSelect {
            display: block !important;
        }
        .scatterplot-mode #systemMultiSelect,
        .scatterplot-mode #phaseMultiSelect {
            display: none !important;
        }
        .scatterplot-mode .form-control {
            display: block;
        }

        /* Aggregation toggle styles */
        .aggregation-toggle {
            margin: 10px 0;
            text-align: center;
        }
        .aggregation-toggle button {
            margin: 0 5px;
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 4px;
        }
        .aggregation-toggle button.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Trials Test Performance Comparison Dashboard</h1>
            <p>Dynamic field site, system and phase analysis with interactive plotting</p>
        </header>

        <div class="dashboard-layout">
            <!-- Control Panel -->
            <div class="control-panel">
                <h3>Selection Parameters</h3>

                <div class="form-group">
                    <label for="variable">Variable:</label>
                    <select id="variable" class="form-control variable-required">
                        <option value="">Loading variables...</option>
                    </select>
                    <div id="variableWarning" class="variable-warning" style="display: none;">
                        Select a variable to view plot
                    </div>
                </div>

                <div class="form-group">
                    <label for="plotType">Plot Type:</label>
                    <div class="plot-type-toggle">
                        <label class="toggle-option">
                            <input type="radio" name="plotType" value="scatterplot" checked>
                            <span>Scatterplot</span>
                        </label>
                        <label class="toggle-option">
                            <input type="radio" name="plotType" value="compare">
                            <span>Compare</span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="site">Field Site:</label>
                    <select id="site" class="form-control">
                        <option value="">All sites (comparison across all field sites)</option>
                    </select>
                    <div id="compareWarning" class="variable-warning" style="display: none;">
                        In compare mode, you must select exactly one site
                    </div>
                </div>

                <div class="form-group">
                    <label for="system">System:</label>
                    <select id="system" class="form-control">
                        <option value="">All systems (optional filter)</option>
                    </select>
                    <div id="systemMultiSelect" class="multi-select" style="display: none;">
                        <!-- Populated dynamically -->
                    </div>
                </div>

                <div class="form-group">
                    <label for="phase">Phase:</label>
                    <select id="phase" class="form-control">
                        <option value="">All phases (optional filter)</option>
                    </select>
                    <div id="phaseMultiSelect" class="multi-select" style="display: none;">
                        <!-- Populated dynamically -->
                    </div>
                </div>

                <button id="plotBtn" class="btn" disabled>Plot Data</button>
                
                <button id="downloadBtn" class="btn btn-secondary" style="display: none;" disabled>Download Data</button>

                <div id="errorMessage" class="error" style="display: none;"></div>
            </div>

            <!-- Plot Panel -->
            <div class="plot-panel">
                <h3>Performance Comparison Plot</h3>
                <div id="aggregationToggle" class="aggregation-toggle" style="display: none;">
                    <button id="byCropBtn" class="active">By Crop</button>
                    <button id="cumulativeBtn">Cumulative by ID</button>
                </div>
                <div id="plotContainer">
                    <div class="loading">
                        Select parameters and click "Plot Data" to generate the plot
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let availableSites = [];
        let selectedSite = ''; // Changed from selectedSites array to single selection
        let selectedSystem = '';
        let selectedPhase = '';
        let selectedVariable = '';
        let plotType = 'scatterplot'; // 'scatterplot' or 'compare'
        let selectedSystems = []; // For compare mode
        let selectedPhases = []; // For compare mode
        let aggregationMode = 'byCrop'; // 'byCrop' or 'cumulative'
        let currentPlotData = null; // Store current plot data for download

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            loadVariables();
            loadSites(); // Load sites first
            loadSystems(); // Load systems based on site selection
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('variable').addEventListener('change', function() {
                selectedVariable = this.value;
                updatePlotButton();
                updateVariableHighlight();
            });

            // Plot type toggle event listeners
            document.querySelectorAll('input[name="plotType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    plotType = this.value;
                    togglePlotMode();
                    updatePlotButton();
                    updateValidationMessages();
                });
            });

            document.getElementById('site').addEventListener('change', function() {
                selectedSite = this.value;
                if (plotType === 'compare') {
                    loadSystemsMultiSelect();
                } else {
                    loadSystems(); // Reload systems when site changes
                }
                updatePlotButton();
                updateValidationMessages();
            });

            document.getElementById('system').addEventListener('change', function() {
                selectedSystem = this.value;
                loadPhases();
                updatePlotButton();
            });

            document.getElementById('phase').addEventListener('change', function() {
                selectedPhase = this.value;
                updatePlotButton();
            });

            document.getElementById('plotBtn').addEventListener('click', generatePlot);
            
            document.getElementById('downloadBtn').addEventListener('click', downloadData);

            // Aggregation toggle event listeners
            document.getElementById('byCropBtn').addEventListener('click', function() {
                aggregationMode = 'byCrop';
                updateAggregationButtons();
                if (plotType === 'compare') regeneratePlot();
            });

            document.getElementById('cumulativeBtn').addEventListener('click', function() {
                aggregationMode = 'cumulative';
                updateAggregationButtons();
                if (plotType === 'compare') regeneratePlot();
            });
        }

        function loadSites() {
            fetch('/api/sites-json')
                .then(response => response.json())
                .then(data => {
                    availableSites = data.sites;
                    const siteSelect = document.getElementById('site');
                    siteSelect.innerHTML = '<option value="">All sites (comparison across all field sites)</option>';
                    
                    data.sites.forEach(site => {
                        const option = document.createElement('option');
                        option.value = site;
                        option.textContent = site;
                        siteSelect.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading sites:', error);
                    showError('Failed to load sites');
                });
        }

        function loadSystems() {
            const systemSelect = document.getElementById('system');
            systemSelect.innerHTML = '<option value="">All systems (optional filter)</option>';
            
            if (!selectedSite) {
                // Load all systems across all sites
                fetch('/api/sites-json')
                    .then(response => response.json())
                    .then(sitesData => {
                        const allSystems = new Set();
                        const promises = sitesData.sites.map(site => 
                            fetch(`/api/systems-json?site=${encodeURIComponent(site)}`)
                                .then(response => response.json())
                                .then(data => data.systems.forEach(system => allSystems.add(system)))
                        );
                        
                        Promise.all(promises).then(() => {
                            Array.from(allSystems).sort().forEach(system => {
                                const option = document.createElement('option');
                                option.value = system;
                                option.textContent = system;
                                systemSelect.appendChild(option);
                            });
                        });
                    });
            } else {
                // Load systems for the selected site only
                fetch(`/api/systems-json?site=${encodeURIComponent(selectedSite)}`)
                    .then(response => response.json())
                    .then(data => {
                        data.systems.forEach(system => {
                            const option = document.createElement('option');
                            option.value = system;
                            option.textContent = system;
                            systemSelect.appendChild(option);
                        });
                    })
                    .catch(error => {
                        console.error('Error loading systems:', error);
                        showError('Failed to load systems');
                    });
            }
            
            // Clear phases when systems change
            selectedSystem = '';
            selectedPhase = '';
            const phaseSelect = document.getElementById('phase');
            phaseSelect.innerHTML = '<option value="">All phases (optional filter)</option>';
        }

        function updateVariableHighlight() {
            const variableSelect = document.getElementById('variable');
            const plotBtn = document.getElementById('plotBtn');
            const warningDiv = document.getElementById('variableWarning');
            
            if (!selectedVariable) {
                variableSelect.classList.add('required');
                plotBtn.classList.add('variable-required');
                warningDiv.style.display = 'block';
            } else {
                variableSelect.classList.remove('required');
                plotBtn.classList.remove('variable-required');
                warningDiv.style.display = 'none';
            }
        }

        function loadPhases() {
            if (!selectedSystem) return;

            const phaseSelect = document.getElementById('phase');
            phaseSelect.innerHTML = '<option value="">All phases (optional filter)</option>';

            if (!selectedSite) {
                // Load phases for the selected system across all sites
                fetch('/api/sites-json')
                    .then(response => response.json())
                    .then(sitesData => {
                        const allPhases = new Set();
                        const promises = sitesData.sites.map(site => 
                            fetch(`/api/phases-json?site=${encodeURIComponent(site)}&system=${encodeURIComponent(selectedSystem)}`)
                                .then(response => response.json())
                                .then(data => data.phases.forEach(phase => allPhases.add(phase)))
                                .catch(() => {}) // Ignore errors for sites that don't have this system
                        );
                        
                        Promise.all(promises).then(() => {
                            Array.from(allPhases).sort().forEach(phase => {
                                const option = document.createElement('option');
                                option.value = phase;
                                option.textContent = phase;
                                phaseSelect.appendChild(option);
                            });
                        });
                    });
            } else {
                // Load phases for the selected system and site
                fetch(`/api/phases-json?site=${encodeURIComponent(selectedSite)}&system=${encodeURIComponent(selectedSystem)}`)
                    .then(response => response.json())
                    .then(data => {
                        data.phases.forEach(phase => {
                            const option = document.createElement('option');
                            option.value = phase;
                            option.textContent = phase;
                            phaseSelect.appendChild(option);
                        });
                    })
                    .catch(error => {
                        console.error('Error loading phases:', error);
                        showError('Failed to load phases');
                    });
            }
        }

        function loadVariables() {
            fetch('/api/variables-json')
                .then(response => response.json())
                .then(data => {
                    const variableSelect = document.getElementById('variable');
                    variableSelect.innerHTML = '<option value="">Select a variable</option>';

                    data.variables.forEach(variable => {
                        const option = document.createElement('option');
                        option.value = variable;
                        option.textContent = variable;
                        variableSelect.appendChild(option);
                    });
                    
                    // Initialize variable highlighting
                    updateVariableHighlight();
                })
                .catch(error => {
                    console.error('Error loading variables:', error);
                    showError('Failed to load variables');
                });
        }

        function updatePlotButton() {
            const plotBtn = document.getElementById('plotBtn');
            
            if (plotType === 'compare') {
                // In compare mode, need variable + valid compare selection
                const canPlot = selectedVariable && validateCompareMode();
                plotBtn.disabled = !canPlot;
            } else {
                // In scatterplot mode, allow plotting with just a variable selected
                const canPlot = selectedVariable;
                plotBtn.disabled = !canPlot;
            }
        }

        function generatePlot() {
            if (!selectedVariable) {
                showError('Please select a variable before plotting');
                return;
            }

            if (plotType === 'compare') {
                if (!validateCompareMode()) {
                    showError('In compare mode, select one site and either 2+ systems OR 1 system + 2+ phases');
                    return;
                }
                generateComparePlot();
            } else {
                generateScatterPlot();
            }
        }

        function generateScatterPlot() {
            // Show loading
            document.getElementById('plotContainer').innerHTML = '<div class="loading">Generating scatterplot...</div>';
            hideError();

            // Build API URL based on selection level
            let apiUrl = `/api/plot-data-json?variable=${encodeURIComponent(selectedVariable)}`;
            
            // Add parameters based on what's selected
            if (selectedSite) {
                apiUrl += `&sites=${encodeURIComponent(selectedSite)}`;
            }
            
            if (selectedSystem) {
                apiUrl += `&system=${encodeURIComponent(selectedSystem)}`;
            }
            
            if (selectedPhase) {
                apiUrl += `&phase=${encodeURIComponent(selectedPhase)}`;
            }

            // Fetch plot data
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(data.error);
                        document.getElementById('plotContainer').innerHTML = '<div class="loading">Error: ' + data.error + '</div>';
                        currentPlotData = null;
                        hideDownloadButton();
                        return;
                    }
                    
                    if (data.data && data.data.length > 0) {
                        currentPlotData = data.data; // Store for download
                        createScatterPlot(data.data);
                        showDownloadButton();
                    } else {
                        currentPlotData = null;
                        hideDownloadButton();
                        showError('No data found for the selected parameters');
                        document.getElementById('plotContainer').innerHTML = '<div class="loading">No data available for selected parameters</div>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching plot data:', error);
                    showError('Failed to fetch plot data');
                    document.getElementById('plotContainer').innerHTML = '<div class="loading">Error loading plot data</div>';
                    currentPlotData = null;
                    hideDownloadButton();
                });
        }

        function generateComparePlot() {
            // Show loading
            document.getElementById('plotContainer').innerHTML = '<div class="loading">Generating comparison plot...</div>';
            hideError();

            // Build API URL for compare mode
            let apiUrl = `/api/plot-data-json?variable=${encodeURIComponent(selectedVariable)}&sites=${encodeURIComponent(selectedSite)}`;
            
            // Fetch plot data
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(data.error);
                        document.getElementById('plotContainer').innerHTML = '<div class="loading">Error: ' + data.error + '</div>';
                        currentPlotData = null;
                        hideDownloadButton();
                        return;
                    }
                    
                    if (data.data && data.data.length > 0) {
                        const filteredData = filterDataForComparison(data.data);
                        if (filteredData.length > 0) {
                            currentPlotData = filteredData; // Store filtered data for download
                            createBoxPlot(filteredData);
                            showDownloadButton();
                        } else {
                            currentPlotData = null;
                            hideDownloadButton();
                            showError('No data found for the selected comparison');
                            document.getElementById('plotContainer').innerHTML = '<div class="loading">No data available for selected comparison</div>';
                        }
                    } else {
                        currentPlotData = null;
                        hideDownloadButton();
                        showError('No data found for the selected parameters');
                        document.getElementById('plotContainer').innerHTML = '<div class="loading">No data available for selected parameters</div>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching plot data:', error);
                    showError('Failed to fetch plot data');
                    document.getElementById('plotContainer').innerHTML = '<div class="loading">Error loading plot data</div>';
                    currentPlotData = null;
                    hideDownloadButton();
                });
        }

        function filterDataForComparison(data) {
            let filtered = data;
            
            // Filter by selected systems or phases
            if (selectedSystems.length >= 2) {
                // Comparing systems
                filtered = data.filter(point => selectedSystems.includes(point.system));
            } else if (selectedSystems.length === 1 && selectedPhases.length >= 2) {
                // Comparing phases within one system
                filtered = data.filter(point => 
                    point.system === selectedSystems[0] && selectedPhases.includes(point.phase)
                );
            }
            
            return filtered;
        }

        function createScatterPlot(data) {
            // Determine the coloring scheme based on selection level
            let colorBy, groupBy, xAxisLabel, plotTitle, plotSubtitle;
            
            if (!selectedSite) {
                // No site selection - color by site
                colorBy = 'site';
                groupBy = 'site';
                xAxisLabel = 'Field Site';
                plotTitle = `${selectedVariable} by Field Site`;
                plotSubtitle = 'All sites, systems, and phases';
            } else if (!selectedSystem) {
                // Site selected but no system - color by system
                colorBy = 'system';
                groupBy = 'system';
                xAxisLabel = 'System';
                plotTitle = `${selectedVariable} by System`;
                plotSubtitle = `Site: ${selectedSite}`;
            } else if (!selectedPhase) {
                // Site and system selected but no phase - color by phase
                colorBy = 'phase';
                groupBy = 'phase';
                xAxisLabel = 'Phase';
                plotTitle = `${selectedVariable} by Phase`;
                plotSubtitle = `Site: ${selectedSite}, System: ${selectedSystem}`;
            } else {
                // All levels selected - use traditional site grouping but will only show one site
                colorBy = 'site';
                groupBy = 'site';
                xAxisLabel = 'Field Site';
                plotTitle = `${selectedVariable} by Field Site`;
                plotSubtitle = `Site: ${selectedSite}, System: ${selectedSystem}, Phase: ${selectedPhase}`;
            }

            // Group data by the determined grouping variable
            const groupedData = {};
            data.forEach(point => {
                const groupKey = point[groupBy];
                if (!groupedData[groupKey]) {
                    groupedData[groupKey] = [];
                }
                groupedData[groupKey].push(point);
            });

            const groupNames = Object.keys(groupedData);
            const plotContainer = document.getElementById('plotContainer');

            // Clear the container
            plotContainer.innerHTML = '';

            // Create SVG
            const svgWidth = 800;
            const svgHeight = 500;
            const margin = { top: 80, right: 50, bottom: 100, left: 80 };
            const plotWidth = svgWidth - margin.left - margin.right;
            const plotHeight = svgHeight - margin.top - margin.bottom;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.border = '1px solid #ddd';
            svg.style.borderRadius = '4px';

            // Get value range for y-axis
            const allValues = data.map(d => parseFloat(d.value)).filter(v => !isNaN(v));
            const minY = Math.min(...allValues);
            const maxY = Math.max(...allValues);
            const yPadding = (maxY - minY) * 0.1;
            const yMin = minY - yPadding;
            const yMax = maxY + yPadding;

            // Color palette - extended for more categories
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];

            // Helper functions for scaling
            function scaleX(groupIndex, jitter = 0.1) {
                const groupSpacing = plotWidth / (groupNames.length || 1);
                return margin.left + groupSpacing * (groupIndex + 0.5) + jitter;
            }

            function scaleY(value) {
                return margin.top + plotHeight - ((value - yMin) / (yMax - yMin)) * plotHeight;
            }

            // Draw axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', margin.top + plotHeight);
            xAxis.setAttribute('x2', margin.left + plotWidth);
            xAxis.setAttribute('y2', margin.top + plotHeight);
            xAxis.setAttribute('stroke', '#666');
            xAxis.setAttribute('stroke-width', '2');
            svg.appendChild(xAxis);

            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', margin.top + plotHeight);
            yAxis.setAttribute('stroke', '#666');
            yAxis.setAttribute('stroke-width', '2');
            svg.appendChild(yAxis);

            // Draw y-axis ticks and labels
            const numYTicks = 5;
            for (let i = 0; i <= numYTicks; i++) {
                const value = yMin + (yMax - yMin) * (i / numYTicks);
                const y = scaleY(value);

                // Tick line
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', margin.left - 5);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', margin.left);
                tick.setAttribute('y2', y);
                tick.setAttribute('stroke', '#666');
                svg.appendChild(tick);

                // Tick label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-family', 'Arial, sans-serif');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = value.toFixed(1);
                svg.appendChild(label);
            }

            // Draw x-axis labels (group names)
            groupNames.forEach((groupName, groupIndex) => {
                const x = scaleX(groupIndex);

                // Tick line
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', margin.top + plotHeight);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', margin.top + plotHeight + 5);
                tick.setAttribute('stroke', '#666');
                svg.appendChild(tick);

                // Group label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', margin.top + plotHeight + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-family', 'Arial, sans-serif');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = groupName;
                svg.appendChild(label);
            });

            // Draw data points
            groupNames.forEach((groupName, groupIndex) => {
                const groupData = groupedData[groupName];
                const color = colors[groupIndex % colors.length];

                groupData.forEach((point, pointIndex) => {
                    const value = parseFloat(point.value);
                    if (isNaN(value)) return;

                    // Add jitter to x position
                    const jitter = (Math.random() - 0.5) * 40; // ±20px jitter
                    const x = scaleX(groupIndex, jitter);
                    const y = scaleY(value);

                    // Create circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '5');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('fill-opacity', '0.7');
                    circle.setAttribute('stroke', color);
                    circle.setAttribute('stroke-width', '1');
                    circle.style.cursor = 'pointer';

                    // Add tooltip on hover
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${colorBy.charAt(0).toUpperCase() + colorBy.slice(1)}: ${groupName}\nSite: ${point.site}\nSystem: ${point.system}\nPhase: ${point.phase}\nPlot: ${point.plot}\nValue: ${value.toFixed(2)}`;
                    circle.appendChild(title);

                    svg.appendChild(circle);
                });
            });

            // Add title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', svgWidth / 2);
            title.setAttribute('y', 25);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-family', 'Arial, sans-serif');
            title.setAttribute('font-size', '16');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('fill', '#333');
            title.textContent = plotTitle;
            svg.appendChild(title);

            // Add subtitle
            const subtitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            subtitle.setAttribute('x', svgWidth / 2);
            subtitle.setAttribute('y', 45);
            subtitle.setAttribute('text-anchor', 'middle');
            subtitle.setAttribute('font-family', 'Arial, sans-serif');
            subtitle.setAttribute('font-size', '12');
            subtitle.setAttribute('fill', '#666');
            subtitle.textContent = plotSubtitle;
            svg.appendChild(subtitle);

            // Add axis labels
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 20);
            yLabel.setAttribute('y', svgHeight / 2);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('font-family', 'Arial, sans-serif');
            yLabel.setAttribute('font-size', '14');
            yLabel.setAttribute('fill', '#333');
            yLabel.setAttribute('transform', `rotate(-90, 20, ${svgHeight / 2})`);
            yLabel.textContent = selectedVariable;
            svg.appendChild(yLabel);

            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', svgWidth / 2);
            xLabel.setAttribute('y', svgHeight - 10);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('font-family', 'Arial, sans-serif');
            xLabel.setAttribute('font-size', '14');
            xLabel.setAttribute('fill', '#333');
            xLabel.textContent = xAxisLabel;
            svg.appendChild(xLabel);

            // Add legend
            const legendStartY = margin.top + 10;
            const legendItemHeight = 20;
            groupNames.forEach((groupName, index) => {
                const color = colors[index % colors.length];
                const legendY = legendStartY + index * legendItemHeight;
                
                // Legend color box
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', svgWidth - margin.right - 100);
                rect.setAttribute('y', legendY - 8);
                rect.setAttribute('width', '12');
                rect.setAttribute('height', '12');
                rect.setAttribute('fill', color);
                rect.setAttribute('stroke', color);
                svg.appendChild(rect);
                
                // Legend text
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', svgWidth - margin.right - 80);
                text.setAttribute('y', legendY);
                text.setAttribute('font-family', 'Arial, sans-serif');
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#333');
                text.textContent = groupName;
                svg.appendChild(text);
            });

            // Add to container
            plotContainer.appendChild(svg);
        }

        function createBoxPlot(data) {
            // Apply aggregation based on mode
            const aggregatedData = aggregationMode === 'cumulative' ? aggregateDataByID(data) : data;
            
            // Determine grouping variable
            let groupBy, plotTitle;
            if (selectedSystems.length >= 2) {
                groupBy = 'system';
                plotTitle = `${selectedVariable} Comparison by System`;
            } else {
                groupBy = 'phase';
                plotTitle = `${selectedVariable} Comparison by Phase`;
            }

            // Group data
            const groupedData = {};
            aggregatedData.forEach(point => {
                const groupKey = point[groupBy];
                if (!groupedData[groupKey]) {
                    groupedData[groupKey] = [];
                }
                groupedData[groupKey].push(point.value);
            });

            const groupNames = Object.keys(groupedData);
            const plotContainer = document.getElementById('plotContainer');

            // Clear the container
            plotContainer.innerHTML = '';

            // Create SVG
            const svgWidth = 800;
            const svgHeight = 500;
            const margin = { top: 80, right: 50, bottom: 100, left: 80 };
            const plotWidth = svgWidth - margin.left - margin.right;
            const plotHeight = svgHeight - margin.top - margin.bottom;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            svg.style.border = '1px solid #ddd';
            svg.style.borderRadius = '4px';

            // Get value range for y-axis
            const allValues = aggregatedData.map(d => d.value).filter(v => !isNaN(v));
            const minY = Math.min(...allValues);
            const maxY = Math.max(...allValues);
            const yPadding = (maxY - minY) * 0.1;
            const yMin = minY - yPadding;
            const yMax = maxY + yPadding;

            // Color palette
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];

            // Helper functions for scaling
            function scaleX(groupIndex) {
                const groupSpacing = plotWidth / (groupNames.length || 1);
                return margin.left + groupIndex * groupSpacing + groupSpacing / 2;
            }

            function scaleY(value) {
                return margin.top + plotHeight - ((value - yMin) / (yMax - yMin)) * plotHeight;
            }

            // Calculate box plot statistics for each group
            groupNames.forEach((groupName, groupIndex) => {
                const values = groupedData[groupName].sort((a, b) => a - b);
                const stats = calculateBoxPlotStats(values);
                const color = colors[groupIndex % colors.length];
                const x = scaleX(groupIndex);
                const boxWidth = Math.min(plotWidth / groupNames.length * 0.6, 60);

                // Draw box plot
                drawBoxPlot(svg, x, boxWidth, stats, color, scaleY);

                // Add group label
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', x);
                xLabel.setAttribute('y', svgHeight - 20);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('font-size', '12');
                xLabel.setAttribute('fill', '#333');
                xLabel.textContent = groupName;
                svg.appendChild(xLabel);
            });

            // Add title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', svgWidth / 2);
            title.setAttribute('y', 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '16');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('fill', '#333');
            title.textContent = plotTitle;
            svg.appendChild(title);

            // Add subtitle
            const subtitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            subtitle.setAttribute('x', svgWidth / 2);
            subtitle.setAttribute('y', 50);
            subtitle.setAttribute('text-anchor', 'middle');
            subtitle.setAttribute('font-size', '12');
            subtitle.setAttribute('fill', '#666');
            subtitle.textContent = `Site: ${selectedSite} | Aggregation: ${aggregationMode === 'cumulative' ? 'Cumulative by ID' : 'By Crop'}`;
            svg.appendChild(subtitle);

            // Add Y-axis
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', margin.top + plotHeight);
            yAxis.setAttribute('stroke', '#333');
            yAxis.setAttribute('stroke-width', '1');
            svg.appendChild(yAxis);

            // Add X-axis
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', margin.top + plotHeight);
            xAxis.setAttribute('x2', margin.left + plotWidth);
            xAxis.setAttribute('y2', margin.top + plotHeight);
            xAxis.setAttribute('stroke', '#333');
            xAxis.setAttribute('stroke-width', '1');
            svg.appendChild(xAxis);

            // Add Y-axis ticks and labels
            const tickCount = 5;
            for (let i = 0; i <= tickCount; i++) {
                const value = yMin + (yMax - yMin) * (i / tickCount);
                const y = scaleY(value);

                // Tick line
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', margin.left - 5);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', margin.left);
                tick.setAttribute('y2', y);
                tick.setAttribute('stroke', '#333');
                tick.setAttribute('stroke-width', '1');
                svg.appendChild(tick);

                // Tick label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '10');
                label.setAttribute('fill', '#666');
                label.textContent = value.toFixed(1);
                svg.appendChild(label);
            }

            // Add Y-axis label
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 20);
            yLabel.setAttribute('y', svgHeight / 2);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('font-size', '12');
            yLabel.setAttribute('fill', '#333');
            yLabel.setAttribute('transform', `rotate(-90, 20, ${svgHeight / 2})`);
            yLabel.textContent = selectedVariable;
            svg.appendChild(yLabel);

            // Add to container
            plotContainer.appendChild(svg);
        }

        function calculateBoxPlotStats(values) {
            if (values.length === 0) return null;

            const sorted = [...values].sort((a, b) => a - b);
            const n = sorted.length;
            
            const q1Index = Math.floor(n * 0.25);
            const medianIndex = Math.floor(n * 0.5);
            const q3Index = Math.floor(n * 0.75);
            
            const q1 = sorted[q1Index];
            const median = n % 2 === 0 ? (sorted[medianIndex - 1] + sorted[medianIndex]) / 2 : sorted[medianIndex];
            const q3 = sorted[q3Index];
            
            const iqr = q3 - q1;
            const lowerWhisker = Math.max(sorted[0], q1 - 1.5 * iqr);
            const upperWhisker = Math.min(sorted[n - 1], q3 + 1.5 * iqr);
            
            // Find outliers
            const outliers = sorted.filter(v => v < lowerWhisker || v > upperWhisker);
            
            return {
                min: sorted[0],
                q1,
                median,
                q3,
                max: sorted[n - 1],
                lowerWhisker,
                upperWhisker,
                outliers
            };
        }

        function drawBoxPlot(svg, centerX, boxWidth, stats, color, scaleY) {
            if (!stats) return;

            const halfWidth = boxWidth / 2;

            // Draw whiskers
            const whiskerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerLine.setAttribute('x1', centerX);
            whiskerLine.setAttribute('y1', scaleY(stats.lowerWhisker));
            whiskerLine.setAttribute('x2', centerX);
            whiskerLine.setAttribute('y2', scaleY(stats.upperWhisker));
            whiskerLine.setAttribute('stroke', color);
            whiskerLine.setAttribute('stroke-width', '1');
            svg.appendChild(whiskerLine);

            // Draw whisker caps
            [stats.lowerWhisker, stats.upperWhisker].forEach(value => {
                const cap = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                cap.setAttribute('x1', centerX - halfWidth * 0.5);
                cap.setAttribute('y1', scaleY(value));
                cap.setAttribute('x2', centerX + halfWidth * 0.5);
                cap.setAttribute('y2', scaleY(value));
                cap.setAttribute('stroke', color);
                cap.setAttribute('stroke-width', '1');
                svg.appendChild(cap);
            });

            // Draw box
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', centerX - halfWidth);
            box.setAttribute('y', scaleY(stats.q3));
            box.setAttribute('width', boxWidth);
            box.setAttribute('height', scaleY(stats.q1) - scaleY(stats.q3));
            box.setAttribute('fill', color);
            box.setAttribute('fill-opacity', '0.3');
            box.setAttribute('stroke', color);
            box.setAttribute('stroke-width', '2');
            svg.appendChild(box);

            // Draw median line
            const medianLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            medianLine.setAttribute('x1', centerX - halfWidth);
            medianLine.setAttribute('y1', scaleY(stats.median));
            medianLine.setAttribute('x2', centerX + halfWidth);
            medianLine.setAttribute('y2', scaleY(stats.median));
            medianLine.setAttribute('stroke', color);
            medianLine.setAttribute('stroke-width', '2');
            svg.appendChild(medianLine);

            // Draw outliers
            stats.outliers.forEach(outlier => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', scaleY(outlier));
                circle.setAttribute('r', '3');
                circle.setAttribute('fill', color);
                circle.setAttribute('fill-opacity', '0.7');
                svg.appendChild(circle);
            });
        }

        function aggregateDataByID(data) {
            const aggregated = {};
            
            data.forEach(point => {
                const id = point.plot;
                if (!aggregated[id]) {
                    aggregated[id] = {
                        plot: id,
                        site: point.site,
                        system: point.system,
                        phase: point.phase,
                        value: 0,
                        count: 0
                    };
                }
                aggregated[id].value += point.value;
                aggregated[id].count += 1;
            });
            
            return Object.values(aggregated).map(item => ({
                ...item,
                value: item.value // Sum, not average - as requested for cumulative
            }));
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function togglePlotMode() {
            const controlPanel = document.querySelector('.control-panel');
            const aggregationToggle = document.getElementById('aggregationToggle');
            
            if (plotType === 'compare') {
                controlPanel.classList.add('compare-mode');
                controlPanel.classList.remove('scatterplot-mode');
                aggregationToggle.style.display = 'block';
                
                // Clear single selections and load multi-selects
                selectedSystem = '';
                selectedPhase = '';
                selectedSystems = [];
                selectedPhases = [];
                loadSystemsMultiSelect();
                loadPhasesMultiSelect();
            } else {
                controlPanel.classList.add('scatterplot-mode');
                controlPanel.classList.remove('compare-mode');
                aggregationToggle.style.display = 'none';
                
                // Clear multi-selections
                selectedSystems = [];
                selectedPhases = [];
            }
        }

        function updateValidationMessages() {
            const compareWarning = document.getElementById('compareWarning');
            const variableWarning = document.getElementById('variableWarning');
            
            if (plotType === 'compare') {
                if (!selectedSite) {
                    compareWarning.style.display = 'block';
                } else {
                    compareWarning.style.display = 'none';
                }
                variableWarning.textContent = 'Select a variable to view comparison plot';
            } else {
                compareWarning.style.display = 'none';
                variableWarning.textContent = 'Select a variable to view plot';
            }
        }

        function updateAggregationButtons() {
            const byCropBtn = document.getElementById('byCropBtn');
            const cumulativeBtn = document.getElementById('cumulativeBtn');
            
            if (aggregationMode === 'byCrop') {
                byCropBtn.classList.add('active');
                cumulativeBtn.classList.remove('active');
            } else {
                byCropBtn.classList.remove('active');
                cumulativeBtn.classList.add('active');
            }
        }

        function loadSystemsMultiSelect() {
            if (!selectedSite) return;
            
            fetch(`/api/systems-json?site=${encodeURIComponent(selectedSite)}`)
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('systemMultiSelect');
                    container.innerHTML = '';
                    
                    data.systems.forEach(system => {
                        const label = document.createElement('label');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = system;
                        checkbox.addEventListener('change', function() {
                            if (this.checked) {
                                selectedSystems.push(system);
                            } else {
                                selectedSystems = selectedSystems.filter(s => s !== system);
                            }
                            loadPhasesMultiSelect();
                            updatePlotButton();
                        });
                        
                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(system));
                        container.appendChild(label);
                    });
                })
                .catch(error => {
                    console.error('Error loading systems:', error);
                });
        }

        function loadPhasesMultiSelect() {
            if (!selectedSite) return;
            
            const container = document.getElementById('phaseMultiSelect');
            container.innerHTML = '';
            
            if (selectedSystems.length === 0) return;
            
            // For now, load phases for the first selected system
            // In a more complex implementation, we might show intersection of phases
            const firstSystem = selectedSystems[0];
            
            fetch(`/api/phases-json?site=${encodeURIComponent(selectedSite)}&system=${encodeURIComponent(firstSystem)}`)
                .then(response => response.json())
                .then(data => {
                    data.phases.forEach(phase => {
                        const label = document.createElement('label');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = phase;
                        checkbox.addEventListener('change', function() {
                            if (this.checked) {
                                selectedPhases.push(phase);
                            } else {
                                selectedPhases = selectedPhases.filter(p => p !== phase);
                            }
                            updatePlotButton();
                        });
                        
                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(phase));
                        container.appendChild(label);
                    });
                })
                .catch(error => {
                    console.error('Error loading phases:', error);
                });
        }

        function validateCompareMode() {
            if (plotType !== 'compare') return true;
            
            if (!selectedSite) return false;
            
            // Must have either 2+ systems OR 1 system + 2+ phases
            if (selectedSystems.length >= 2) return true;
            if (selectedSystems.length === 1 && selectedPhases.length >= 2) return true;
            
            return false;
        }

        function regeneratePlot() {
            if (plotType === 'compare' && validateCompareMode() && selectedVariable) {
                generatePlot();
            }
        }
        
        function showDownloadButton() {
            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.style.display = 'block';
            downloadBtn.disabled = false;
        }
        
        function hideDownloadButton() {
            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.style.display = 'none';
            downloadBtn.disabled = true;
        }
        
        function downloadData() {
            if (!currentPlotData || !selectedVariable) {
                showError('No plot data available for download');
                return;
            }
            
            try {
                const csvData = generateCSVFromPlotData(currentPlotData, selectedVariable);
                const filename = generateDownloadFilename();
                downloadCSVFile(csvData, filename);
            } catch (error) {
                console.error('Error generating CSV:', error);
                showError('Failed to generate download file');
            }
        }
        
        function generateCSVFromPlotData(data, variable) {
            // Group data by system and phase for statistical analysis
            const groups = {};
            
            data.forEach(point => {
                const key = `${point.site}_${point.system}_${point.phase}`;
                if (!groups[key]) {
                    groups[key] = {
                        site: point.site,
                        system: point.system,
                        phase: point.phase,
                        values: []
                    };
                }
                groups[key].values.push(point.value);
            });
            
            // Calculate statistics for each group
            const statsData = [];
            Object.values(groups).forEach(group => {
                const values = group.values;
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                
                statsData.push({
                    site: group.site,
                    system: group.system,
                    phase: group.phase,
                    variable: variable,
                    count: values.length,
                    mean: mean.toFixed(4),
                    std_dev: stdDev.toFixed(4),
                    min: Math.min(...values).toFixed(4),
                    max: Math.max(...values).toFixed(4)
                });
            });
            
            // Generate CSV header
            let csv = 'Site,System,Phase,Variable,Count,Mean,Standard_Deviation,Minimum,Maximum\\n';
            
            // Add data rows
            statsData.forEach(row => {
                csv += `"${row.site}","${row.system}","${row.phase}","${row.variable}",${row.count},${row.mean},${row.std_dev},${row.min},${row.max}\\n`;
            });
            
            // Add comparison analysis for compare mode
            if (plotType === 'compare' && statsData.length >= 2) {
                csv += '\\n\\nComparison Analysis\\n';
                csv += 'Group_A,Group_B,Mean_Difference,Statistical_Note\\n';
                
                for (let i = 0; i < statsData.length; i++) {
                    for (let j = i + 1; j < statsData.length; j++) {
                        const groupA = statsData[i];
                        const groupB = statsData[j];
                        const meanDiff = (parseFloat(groupA.mean) - parseFloat(groupB.mean)).toFixed(4);
                        const groupAName = `${groupA.system}_${groupA.phase}`;
                        const groupBName = `${groupB.system}_${groupB.phase}`;
                        csv += `"${groupAName}","${groupBName}",${meanDiff},"Descriptive comparison only"\\n`;
                    }
                }
            }
            
            return csv;
        }
        
        function generateDownloadFilename() {
            const date = new Date().toISOString().split('T')[0];
            const variableName = selectedVariable.replace(/[^a-zA-Z0-9]/g, '_');
            let filename = `trials_data_${variableName}_${date}`;
            
            if (plotType === 'compare' && selectedSite) {
                filename += `_${selectedSite}`;
            }
            
            return filename + '.csv';
        }
        
        function downloadCSVFile(csvContent, filename) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // Fallback for browsers that don't support download attribute
                window.open('data:text/csv;charset=utf-8,' + encodeURI(csvContent));
            }
        }
    </script>
</body>
</html>